(2024-02-08) 프로젝트 시작 <br></br>
(2024-02-08) ERD 설계 
![초안_erd](https://github.com/HuttTheJAVA/Shoping_Mall_Project/assets/92637789/b0f5542d-1913-40d1-a1df-ba17a6a51d75)<br></br><br></br>
(2024-02-27) ERD 수정
![image](https://github.com/HuttTheJAVA/Shoping_Mall_Project/assets/92637789/bba0d70c-7d08-4deb-84a9-2e9c968505f2)

<br></br><br></br>
(2024-02-28) 코딩 시작   
>1.persistence.xml   
>2.application.yml   
>3.엔티티 관계 구현   
>4.MemberRepository & OrderRepository 구현 및 테스트 코드 작성.

<br></br>

(2024-02-29)
>1.생성자 매개변수가 많은 Member,Order를 Builder 방식으로 변경<br>
>2.Member,Order,Item Repository 코드 수정<br>
>3.Repository 테스트 코드 재작성 (Unique column에 대한 중복 테스트 코드에서 예상치 못한 오류로 인해 많이 지체됨.<br>
>(https://colabear754.tistory.com/162) 를 참고해서 해결함.

<br></br>
(2024-03-04)
>1.엔티티 매핑 마무리<br>
>2.홈페이지(index.html) 작성

<br></br>
(2024-03-05)   
>1.홈페이지에서 상단의 로고와 메뉴바를 타임리프 조각으로 분리화(상단은 계속 재활용) <br>(css파일은 꼭 static/css에 넣자)<br>
>2.로그인,회원가입,연락방법(contactUs) 페이지 작성 및 홈페이지에서 메뉴바의 로그인,회원가입,연락방법 누르면 해당 페이지로 넘어가게 연동(HomeController를 통해).<br>
>3.연락방법 페이지에 메뉴바 템플릿 조각 재활용하여 페이지 렌더링.

<br></br>
(2024-03-06)
>1.로그인,회원가입(Join) 컨트롤러 구현 <br>
>2.로그인,회원가입(Join) 서비스 구현<br> (로그인: 아이디,비번 db에서 대조, 회원가입: 중복되는 user_id,nickName 확인)<br>
>3.로그인,회원가입 실패 시 빨간 강조된 에러 메시지를 표시하도록 로그인,회원가입 페이지 수정<br>
>4.DTO 클래스 구현(MemberDTO,ItemDTO)<br>
>5.회원가입 환영 페이지 작성<br></br>
>배운점: 모든 엔티티는 기본 생성자(매개변수 없는)를 꼭 가져야 한다. 이는 JPA Reflection이라는 기술 때문인데 FetchType.LAZY일 때 엔티티와 연관된 엔티티들을 참조하는 시점에 영속성 컨텍스트에 로딩한다. 바꿔말하면 엔티티를 영속성 컨텍스트에 로딩할 때 엔티티와 연관된 엔티티는 가짜 객체로 로딩하는데 이게 프록시 객체이다. 근데 JPA Reflection을 통해 프록시 객체를 만들기 위해서는 아무 매개변수가 필요없는 기본 생성자가 필요하다.(참고사이트 https://hyeonic.tistory.com/191)
>
<br></br>
(2024-03-07)<br>
>1. Spring Security를 시스템에 도입하는데 난관에 봉착.(formLogin.loginProcessingUrl("URL")에서 loginProcessingUrl이 로그인 로직을 처리할 url을 지정(method=Post)라길래 @PostMappint("URL")인 컨트롤러로 이동하는줄 알았는데 그게 아니고 Spring Security가 처리한다고 해서 추가적인 자료조사필요.)

<br></br>
(2024-03-08)<br>
>1. Member 엔티티의 user_id를 userId로 수정. <br>(Spring data JPA 인터페이스를 통한 repository의 쿼리 메소드를 사용할 때는 쿼리 메소드의 필드명에 언더바(_)가 들어가는 필드가 있으면 안됨.)<br>
>2. 예제 코드로 spring security 적용 성공. 향후 프로젝트에 spring security 도입할 예정.

<br></br>
(2024-03-11)<br>
>1. Spring Security 프로젝트에 도입. (Bcrypt 방식으로 인증,"ROLE_XXX" 방식으로 인가)<br>
>2. Spring Security 도입 중 **"could not initialize proxy - no Session"** 문제 발생. (해결 방안: @Transactional을 서비스 밖까지 선언해 세션을 유지하여 Lazy load가 가능하게 함.(그러나 조회에 트랜잭션을 거는 것이 최선책은 아닌 것 같다.)<br>
>3. header 템플릿 조각을 수정해 로그인 상태이면 사용자 이름과 로그아웃이 렌더링, 로그아웃 상태라면 로그인, 회원가입이 렌더링 되도록 html 수정.<br>
>4. Interceptor의 preIntercept 메소드에서 요청의 인증 상태를 확인해 id,role을 httpRequest에 미리 담아줌. 위 3번의 로그인의 상태에 따라 렌더링을 다르게 하는 부분에서 header 템플릿 조각을 포함하는 뷰를 리턴하는 모든 컨트롤러들에 대해서 Interceptor가 담아준 id,role을 httpRequest에서 꺼내 model에 담아서 뷰를 리턴.

<br></br>
(2024-03-12)<br>
>1. 로그인 세션 만료 시간 설정 및 한 계정 최대 세션 1개로 제한(중복 접속 불가)
>2. 로그인 상태에서 header 템플릿 조각의 사용자 이름을 누르면 사용자 개인 정보 페이지로 이동
>3. 아이템 DTO 구현 및 아이템 컨트롤러 작성
>4. (관리자)아이템 등록과 사진을 고정된 저장경로에 저장 (추후 아이템 상세 뷰 작성예정.)

<br></br>
(2024-03-13)<br>
>1. itemService와 아이템 상세 페이지 작성 (이미지 렌더링 + 수량에 따라 가격이 페이지에서 동적으로 바뀌게)

배운점: th:src에는 파일 시스템의 경로가 아니라 클라이언트가 원하는 이미지를 서버로 부터 얻을 수 있는 **URL**을 넣어야 한다.<br> 관리자가 아이템 이미지를 업로드하고 그 경로를 string으로 item에 저장하고 item을 Model에 넣어주고 redirect로 렌더링하려는데 엑박이 떴다. 한참 찾아보니 th:src=@{images/item.uploadFileName}으로 html을 작성했는데 이는 파일 시스템의 경로였다. <br>근데 왜 파일 시스템의 경로에 있는 파일을 못찾지? 생각을 해봤는데 생각해보니 클라이언트 입장에서는 이미지를 얻으려면 서버에게 다시 요청해야하고 URL로 요청 하는데 서버 파일 시스템의 경로를 입력했으니 못 찾는거였다. 다시말해 서버는 파일 시스템의 경로를 RequestMapping으로 가지는 컨트롤러가 없는거다. 그리고 다시 든 의문이 static/images에 있던 이미지들은 파일 시스템의 경로로 잘 되던데? 였다. 이는 스프링이 static에 대해서는 스프링부트가 내장 TOMCAT 서버를 서빙할 때 기본 정적 리소스 설정 경로를(classpath:/static/) 자동으로 제공해준다.
<p align="center">
  <img width="410" alt="image" src="https://github.com/HuttTheJAVA/Shoping_Mall_Project/assets/92637789/435fb666-e670-4195-be34-7a200dc031da">
</p>

<br></br>
(2024-03-14)<br>
>1. 유저 엔티티에 포인트 필드 추가 (결제에 사용)
>2. 비회원에 대한 장바구니를 어떻게 구현할지 구상. (쿠키에 장바구니 아이템들을 문자열로 클라이언트 측에 저장, 유지시간은 하루)
>3. userId를 "anonymousUser"으로 가입 못하게 JoinController의 로직 변경
>4. 장바구니 컨트롤러에 Interceptor에서 넣어준 id로 "anonymousUser"인지 아닌지 식별하고 "anonymousUser"라면 "Cart"라는 이름을 가진 쿠키를 열어서 그 안에 아이템들을 Model에 추가해서 뷰로 넘길 예정 (로그인 사용자라면 DB에서 사용자의 CartId를 가지는 CartItem들을 조회할 예정)
