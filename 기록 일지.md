(2024-02-08) 프로젝트 시작 <br></br>
(2024-02-08) ERD 설계 
![초안_erd](https://github.com/HuttTheJAVA/Shoping_Mall_Project/assets/92637789/b0f5542d-1913-40d1-a1df-ba17a6a51d75)<br></br><br></br>
(2024-02-27) ERD 수정
![image](https://github.com/HuttTheJAVA/Shoping_Mall_Project/assets/92637789/bba0d70c-7d08-4deb-84a9-2e9c968505f2)

<br></br><br></br>
(2024-02-28) 코딩 시작   
>1.persistence.xml   
>2.application.yml   
>3.엔티티 관계 구현   
>4.MemberRepository & OrderRepository 구현 및 테스트 코드 작성.

<br></br>

(2024-02-29)
>1.생성자 매개변수가 많은 Member,Order를 Builder 방식으로 변경<br>
>2.Member,Order,Item Repository 코드 수정<br>
>3.Repository 테스트 코드 재작성 (Unique column에 대한 중복 테스트 코드에서 예상치 못한 오류로 인해 많이 지체됨.<br>
>(https://colabear754.tistory.com/162) 를 참고해서 해결함.

<br></br>
(2024-03-04)
>1.엔티티 매핑 마무리<br>
>2.홈페이지(index.html) 작성

<br></br>
(2024-03-05)   
>1.홈페이지에서 상단의 로고와 메뉴바를 타임리프 조각으로 분리화(상단은 계속 재활용) <br>(css파일은 꼭 static/css에 넣자)<br>
>2.로그인,회원가입,연락방법(contactUs) 페이지 작성 및 홈페이지에서 메뉴바의 로그인,회원가입,연락방법 누르면 해당 페이지로 넘어가게 연동(HomeController를 통해).<br>
>3.연락방법 페이지에 메뉴바 템플릿 조각 재활용하여 페이지 렌더링.

<br></br>
(2024-03-06)
>1.로그인,회원가입(Join) 컨트롤러 구현 <br>
>2.로그인,회원가입(Join) 서비스 구현<br> (로그인: 아이디,비번 db에서 대조, 회원가입: 중복되는 user_id,nickName 확인)<br>
>3.로그인,회원가입 실패 시 빨간 강조된 에러 메시지를 표시하도록 로그인,회원가입 페이지 수정<br>
>4.DTO 클래스 구현(MemberDTO,ItemDTO)<br>
>5.회원가입 환영 페이지 작성<br></br>
>배운점: 모든 엔티티는 기본 생성자(매개변수 없는)를 꼭 가져야 한다. 이는 JPA Reflection이라는 기술 때문인데 FetchType.LAZY일 때 엔티티와 연관된 엔티티들을 참조하는 시점에 영속성 컨텍스트에 로딩한다. 바꿔말하면 엔티티를 영속성 컨텍스트에 로딩할 때 엔티티와 연관된 엔티티는 가짜 객체로 로딩하는데 이게 프록시 객체이다. 근데 JPA Reflection을 통해 프록시 객체를 만들기 위해서는 아무 매개변수가 필요없는 기본 생성자가 필요하다.(참고사이트 https://hyeonic.tistory.com/191)
>
<br></br>
(2024-03-07)<br>
>1. Spring Security를 시스템에 도입하는데 난관에 봉착.(formLogin.loginProcessingUrl("URL")에서 loginProcessingUrl이 로그인 로직을 처리할 url을 지정(method=Post)라길래 @PostMappint("URL")인 컨트롤러로 이동하는줄 알았는데 그게 아니고 Spring Security가 처리한다고 해서 추가적인 자료조사필요.)

<br></br>
(2024-03-08)<br>
>1. Member 엔티티의 user_id를 userId로 수정. <br>(Spring data JPA 인터페이스를 통한 repository의 쿼리 메소드를 사용할 때는 쿼리 메소드의 필드명에 언더바(_)가 들어가는 필드가 있으면 안됨.)<br>
>2. 예제 코드로 spring security 적용 성공. 향후 프로젝트에 spring security 도입할 예정.

<br></br>
(2024-03-11)<br>
>1. Spring Security 프로젝트에 도입. (Bcrypt 방식으로 인증,"ROLE_XXX" 방식으로 인가)<br>
>2. Spring Security 도입 중 **"could not initialize proxy - no Session"** 문제 발생. (해결 방안: @Transactional을 서비스 밖까지 선언해 세션을 유지하여 Lazy load가 가능하게 함.(그러나 조회에 트랜잭션을 거는 것이 최선책은 아닌 것 같다.)<br>
>3. header 템플릿 조각을 수정해 로그인 상태이면 사용자 이름과 로그아웃이 렌더링, 로그아웃 상태라면 로그인, 회원가입이 렌더링 되도록 html 수정.<br>
>4. Interceptor의 preIntercept 메소드에서 요청의 인증 상태를 확인해 id,role을 httpRequest에 미리 담아줌. 위 3번의 로그인의 상태에 따라 렌더링을 다르게 하는 부분에서 header 템플릿 조각을 포함하는 뷰를 리턴하는 모든 컨트롤러들에 대해서 Interceptor가 담아준 id,role을 httpRequest에서 꺼내 model에 담아서 뷰를 리턴.

<br></br>
(2024-03-12)<br>
>1. 로그인 세션 만료 시간 설정 및 한 계정 최대 세션 1개로 제한(중복 접속 불가)
>2. 로그인 상태에서 header 템플릿 조각의 사용자 이름을 누르면 사용자 개인 정보 페이지로 이동
>3. 아이템 DTO 구현 및 아이템 컨트롤러 작성
>4. (관리자)아이템 등록과 사진을 고정된 저장경로에 저장 (추후 아이템 상세 뷰 작성예정.)

<br></br>
(2024-03-13)<br>
>1. itemService와 아이템 상세 페이지 작성 (이미지 렌더링 + 수량에 따라 가격이 페이지에서 동적으로 바뀌게)

배운점: th:src에는 파일 시스템의 경로가 아니라 클라이언트가 원하는 이미지를 서버로 부터 얻을 수 있는 **URL**을 넣어야 한다.<br> 관리자가 아이템 이미지를 업로드하고 그 경로를 string으로 item에 저장하고 item을 Model에 넣어주고 redirect로 렌더링하려는데 엑박이 떴다. 한참 찾아보니 th:src=@{images/item.uploadFileName}으로 html을 작성했는데 이는 파일 시스템의 경로였다. <br>근데 왜 파일 시스템의 경로에 있는 파일을 못찾지? 생각을 해봤는데 생각해보니 클라이언트 입장에서는 이미지를 얻으려면 서버에게 다시 요청해야하고 URL로 요청 하는데 서버 파일 시스템의 경로를 입력했으니 못 찾는거였다. 다시말해 서버는 파일 시스템의 경로를 RequestMapping으로 가지는 컨트롤러가 없는거다. 그리고 다시 든 의문이 static/images에 있던 이미지들은 파일 시스템의 경로로 잘 되던데? 였다. 이는 스프링이 static에 대해서는 스프링부트가 내장 TOMCAT 서버를 서빙할 때 기본 정적 리소스 설정 경로를(classpath:/static/) 자동으로 제공해준다.
<p align="center">
  <img width="410" alt="image" src="https://github.com/HuttTheJAVA/Shoping_Mall_Project/assets/92637789/435fb666-e670-4195-be34-7a200dc031da">
</p>

<br></br>
(2024-03-14)<br>
>1. 유저 엔티티에 포인트 필드 추가 (결제에 사용)
>2. 비회원에 대한 장바구니를 어떻게 구현할지 구상.<br> (쿠키에 장바구니 아이템들을 문자열로 클라이언트 측에 저장, 유지시간은 하루)
>3. userId를 "anonymousUser"으로 가입 못하게 JoinController의 로직 변경
>4. 장바구니 컨트롤러에 Interceptor에서 넣어준 id로 "anonymousUser"인지 아닌지 식별하고 "anonymousUser"라면 "Cart"라는 이름을 가진 쿠키를 열어서 그 안에 아이템들을 Model에 추가해서 뷰로 넘길 예정<br> (로그인 사용자라면 DB에서 사용자의 CartId를 가지는 CartItem들을 조회할 예정)

<br></br>
(2024-03-15)<br>
>1. Cart 엔티티 제거. 사용자 1명 당 한개의 장바구니만 허용.(장바구니 여러개 만들게 허용하면 복잡해지고 장바구니 여러개 만들어 놓기만 하고 안 살 확률이 높음. 또한 서버가 여러개의 장바구니를 저장하는 부담을 줄이기 위함.)
>2. CartItem은 MemberId로 멤버별 장바구니에 속하는 아이템을 식별한다.

<br></br>
(2024-03-18)<br>
>1. 장바구니 렌더링하는 페이지 부분 구현
>2. 비회원 = 쿠키(1일 지속) , 회원 = DB로 장바구니 아이템 저장.
>3. 비회원에서 로그인하면 기존의 회원 장바구니와 쿠키에 저장돼 있던 아이템들을 합침.
>4. 이미 장바구니에 있는 아이템을 또 장바구니에 담으면 CartItem을 중복 생성하되 나중에 장바구니 렌더링하기 전에 장바구니에 중복된 아이템들을 하나로 합산하는 코드 작성. (리스트와 해시맵으로 구현)
>5. 장바구니 -,+로 수량 조정할 때 마다 DB에 I/O하는 것이 비효율적이라 Redis로 수량을 캐시화 한 후 나중에 I/O 반영할 생각(Redis 공부 및 연습코드로 연습 필요)

<br></br>
(2024-03-20)<br>
>1. 장바구니 페이지에서 -,+을 누를 때 마다 DB에 CartItem의 quantity를 바로 반영하는 것이 비효율적이라고 생각했음.<br>
>2. 이에 따라 Redis,Spring Cache를 고려했으나 좀 더 생각해보니 여러가지 이유로 인해 바로 DB에 반영하는 것이 나을 것 같다고 판단함.<br>
1. 장바구니 수량을 변경할 때 2 -> 100으로 변경하면 +을 98번 누르게 되는데 이는 DB로 98번 I/O가 가게 된다. 그러나 98번 버튼을 누르는 사람은 거의 없을 것이다. 그냥 100을 입력하지.<br>
2. 2번째로는 캐시에 장바구니 최신 quantity를 저장하고 일정 시간이 지나면 폼에 있는 장바구니 아이템 quantity와 캐시를 비교해 바뀐 애들만 DB에 반영하는 방법을 생각했으나, 사용자가
장바구니 수량을 몇개 변경하고 바로 창을 닫아버릴 수도 있다는 문제가 있다.<br>
3. 이에 따라 내린 결론은 수량 변경을 바로 db나 쿠키(비로그인의 경우)에 반영한다는 것이다.<br>
4. 그러나 -,+을 누르고 서버에서 응답이 돌아올 때 까지 폼을 못 건드리게 멈춰야할 것 같다.(사용자가 +를 광클하여 누른 횟수만큼 서버에 제대로 반영되지 않을 경우를 대비하여.) 그렇다고 엄청 오래 멈추지는 않을 것이다.(이와 유사하게 쿠팡의 장바구니도 -,+를 누르면 0.2초 정도의 버벅임이 있는 이유가 이와 같은 이유가 아닐까 추정한다.)

<br></br>
(2024-03-21)<br>
예비군 작계훈련

<br></br>
(2024-03-22)<br>
>1.비회원의 -,+ 수량 수정에 따른 쿠키 수정 코드 작성.<br>
>2.비회원이 장바구니 아이템을 삭제시 쿠키상 해당 아이템 삭제하는 코드 작성 및 페이지에서도 아이템 테이블 행 제거.<br>
>3.비회원에서 회원으로 로그인 할 경우 쿠키의 모든 CartItem을 DB에 반영<br> (새로운 CartItem이면 새로 생성, 이미 같은 item.id를 가진 CartItem이 존재한다면 수량만 업데이트트.)
